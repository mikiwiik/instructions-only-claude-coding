import type { Todo, TodoFilter, TodoState } from '../../types/todo';

// Enhanced Todo type with deletedAt for testing soft delete functionality
interface EnhancedTodo extends Todo {
  deletedAt?: Date;
}

// Enhanced filter types for soft delete support
type EnhancedTodoFilter =
  | TodoFilter
  | 'deleted'
  | 'recently-updated'
  | 'recently-deleted'
  | 'recently-completed';

// Enhanced state interface for soft delete filtering
interface EnhancedTodoState extends Omit<TodoState, 'filter'> {
  filter: EnhancedTodoFilter;
}

describe('Enhanced Todo Types with Soft Delete Support', () => {
  describe('EnhancedTodo interface', () => {
    it('should extend base Todo with optional deletedAt field', () => {
      const activeTodo: EnhancedTodo = {
        id: '1',
        text: 'Active todo',
        completedAt: undefined,
        createdAt: new Date('2024-01-01T10:00:00Z'),
        updatedAt: new Date('2024-01-01T10:00:00Z'),
        // deletedAt is optional
      };

      expect(activeTodo).toHaveProperty('id');
      expect(activeTodo).toHaveProperty('text');
      expect(activeTodo).toHaveProperty('completedAt');
      expect(activeTodo).toHaveProperty('createdAt');
      expect(activeTodo).toHaveProperty('updatedAt');
      expect(activeTodo.deletedAt).toBeUndefined();

      expect(typeof activeTodo.id).toBe('string');
      expect(typeof activeTodo.text).toBe('string');
      expect(activeTodo.completedAt).toBeUndefined();
      expect(activeTodo.createdAt).toBeInstanceOf(Date);
      expect(activeTodo.updatedAt).toBeInstanceOf(Date);
    });

    it('should support deletedAt field for soft deleted todos', () => {
      const deletedTodo: EnhancedTodo = {
        id: '2',
        text: 'Deleted todo',
        completedAt: undefined,
        createdAt: new Date('2024-01-01T10:00:00Z'),
        updatedAt: new Date('2024-01-01T11:00:00Z'),
        deletedAt: new Date('2024-01-01T12:00:00Z'),
      };

      expect(deletedTodo).toHaveProperty('deletedAt');
      expect(deletedTodo.deletedAt).toBeInstanceOf(Date);
      expect(deletedTodo.deletedAt?.getTime()).toBeGreaterThan(
        deletedTodo.updatedAt.getTime()
      );
    });

    it('should maintain backward compatibility with base Todo interface', () => {
      // Should be able to use base Todo as EnhancedTodo
      const baseTodo: Todo = {
        id: '3',
        text: 'Base todo',
        completed: true,
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      const enhancedTodo: EnhancedTodo = baseTodo;

      expect(enhancedTodo.id).toBe(baseTodo.id);
      expect(enhancedTodo.text).toBe(baseTodo.text);
      expect(enhancedTodo.completed).toBe(baseTodo.completed);
      expect(enhancedTodo.deletedAt).toBeUndefined();
    });

    it('should support different completion and deletion states', () => {
      const scenarios: Array<{
        name: string;
        todo: EnhancedTodo;
        expectedState: string;
      }> = [
        {
          name: 'active incomplete',
          todo: {
            id: '1',
            text: 'Active todo',
            completedAt: undefined,
            createdAt: new Date('2024-01-01T10:00:00Z'),
            updatedAt: new Date('2024-01-01T10:00:00Z'),
          },
          expectedState: 'active',
        },
        {
          name: 'completed',
          todo: {
            id: '2',
            text: 'Completed todo',
            completed: true,
            createdAt: new Date('2024-01-01T10:00:00Z'),
            updatedAt: new Date('2024-01-01T11:00:00Z'),
          },
          expectedState: 'completed',
        },
        {
          name: 'soft deleted incomplete',
          todo: {
            id: '3',
            text: 'Deleted todo',
            completedAt: undefined,
            createdAt: new Date('2024-01-01T10:00:00Z'),
            updatedAt: new Date('2024-01-01T11:00:00Z'),
            deletedAt: new Date('2024-01-01T12:00:00Z'),
          },
          expectedState: 'deleted',
        },
        {
          name: 'soft deleted completed',
          todo: {
            id: '4',
            text: 'Completed then deleted',
            completed: true,
            createdAt: new Date('2024-01-01T10:00:00Z'),
            updatedAt: new Date('2024-01-01T11:00:00Z'),
            deletedAt: new Date('2024-01-01T12:00:00Z'),
          },
          expectedState: 'deleted',
        },
      ];

      scenarios.forEach(({ todo, expectedState }) => {
        const isDeleted = !!todo.deletedAt;
        const isCompleted = todo.completed;
        const isActive = !isCompleted && !isDeleted;

        switch (expectedState) {
          case 'active':
            expect(isActive).toBe(true);
            expect(isCompleted).toBe(false);
            expect(isDeleted).toBe(false);
            break;
          case 'completed':
            expect(isCompleted).toBe(true);
            expect(isDeleted).toBe(false);
            break;
          case 'deleted':
            expect(isDeleted).toBe(true);
            break;
        }
      });
    });
  });

  describe('EnhancedTodoFilter types', () => {
    it('should include all base filter types', () => {
      const baseFilters: TodoFilter[] = ['all', 'active', 'completed'];
      const enhancedFilters: EnhancedTodoFilter[] = [
        ...baseFilters,
        'deleted',
        'recently-updated',
        'recently-deleted',
        'recently-completed',
      ];

      baseFilters.forEach((filter) => {
        expect(enhancedFilters).toContain(filter);
      });
    });

    it('should support new filter types for soft delete functionality', () => {
      const newFilters: EnhancedTodoFilter[] = [
        'deleted',
        'recently-updated',
        'recently-deleted',
        'recently-completed',
      ];

      newFilters.forEach((filter) => {
        expect(typeof filter).toBe('string');
        expect(filter.length).toBeGreaterThan(0);
      });
    });

    it('should be assignable to string type for flexibility', () => {
      const filters: EnhancedTodoFilter[] = [
        'all',
        'active',
        'completed',
        'deleted',
        'recently-updated',
        'recently-deleted',
        'recently-completed',
      ];

      filters.forEach((filter) => {
        const filterString: string = filter;
        expect(typeof filterString).toBe('string');
      });
    });
  });

  describe('EnhancedTodoState interface', () => {
    it('should support enhanced filter types', () => {
      const enhancedState: EnhancedTodoState = {
        todos: [],
        filter: 'recently-deleted',
      };

      expect(enhancedState).toHaveProperty('todos');
      expect(enhancedState).toHaveProperty('filter');
      expect(Array.isArray(enhancedState.todos)).toBe(true);
      expect(enhancedState.filter).toBe('recently-deleted');
    });

    it('should maintain compatibility with base TodoState for standard filters', () => {
      const baseState: TodoState = {
        todos: [],
        filter: 'all',
      };

      // Should be able to assign base state to enhanced state for compatible filters
      const enhancedState: EnhancedTodoState = {
        ...baseState,
        filter: baseState.filter as EnhancedTodoFilter,
      };

      expect(enhancedState.filter).toBe('all');
    });

    it('should support todos with mixed deletion states', () => {
      const mixedTodos: EnhancedTodo[] = [
        {
          id: '1',
          text: 'Active todo',
          completedAt: undefined,
          createdAt: new Date('2024-01-01T10:00:00Z'),
          updatedAt: new Date('2024-01-01T10:00:00Z'),
        },
        {
          id: '2',
          text: 'Completed todo',
          completed: true,
          createdAt: new Date('2024-01-01T10:00:00Z'),
          updatedAt: new Date('2024-01-01T11:00:00Z'),
        },
        {
          id: '3',
          text: 'Deleted todo',
          completedAt: undefined,
          createdAt: new Date('2024-01-01T10:00:00Z'),
          updatedAt: new Date('2024-01-01T11:00:00Z'),
          deletedAt: new Date('2024-01-01T12:00:00Z'),
        },
      ];

      const state: EnhancedTodoState = {
        todos: mixedTodos,
        filter: 'all',
      };

      expect(state.todos).toHaveLength(3);
      expect(state.todos.filter((todo) => !!todo.deletedAt)).toHaveLength(1);
      expect(state.todos.filter((todo) => todo.completed)).toHaveLength(1);
      expect(
        state.todos.filter((todo) => !todo.completed && !todo.deletedAt)
      ).toHaveLength(1);
    });
  });

  describe('type compatibility and migration', () => {
    it('should allow migration from base Todo to EnhancedTodo', () => {
      const baseTodos: Todo[] = [
        {
          id: '1',
          text: 'Base todo 1',
          completedAt: undefined,
          createdAt: new Date(),
          updatedAt: new Date(),
        },
        {
          id: '2',
          text: 'Base todo 2',
          completed: true,
          createdAt: new Date(),
          updatedAt: new Date(),
        },
      ];

      // Migrate base todos to enhanced todos
      const enhancedTodos: EnhancedTodo[] = baseTodos.map((todo) => ({
        ...todo,
        deletedAt: undefined, // Explicitly set for clarity
      }));

      expect(enhancedTodos).toHaveLength(2);
      enhancedTodos.forEach((todo) => {
        expect(todo).toHaveProperty('id');
        expect(todo).toHaveProperty('text');
        expect(todo).toHaveProperty('completed');
        expect(todo).toHaveProperty('createdAt');
        expect(todo).toHaveProperty('updatedAt');
        expect(todo.deletedAt).toBeUndefined();
      });
    });

    it('should support JSON serialization and deserialization', () => {
      const enhancedTodo: EnhancedTodo = {
        id: 'json-test',
        text: 'JSON serializable todo',
        completedAt: undefined,
        createdAt: new Date('2024-01-01T10:00:00Z'),
        updatedAt: new Date('2024-01-01T11:00:00Z'),
        deletedAt: new Date('2024-01-01T12:00:00Z'),
      };

      // Serialize to JSON
      const serialized = JSON.stringify(enhancedTodo);
      expect(typeof serialized).toBe('string');

      // Deserialize from JSON
      const deserialized = JSON.parse(serialized);
      expect(deserialized.id).toBe(enhancedTodo.id);
      expect(deserialized.text).toBe(enhancedTodo.text);
      expect(deserialized.completed).toBe(enhancedTodo.completed);

      // Note: Dates become strings after JSON serialization
      expect(typeof deserialized.createdAt).toBe('string');
      expect(typeof deserialized.updatedAt).toBe('string');
      expect(typeof deserialized.deletedAt).toBe('string');

      // Reconstruct with Date objects
      const reconstructed: EnhancedTodo = {
        ...deserialized,
        createdAt: new Date(deserialized.createdAt),
        updatedAt: new Date(deserialized.updatedAt),
        deletedAt: deserialized.deletedAt
          ? new Date(deserialized.deletedAt)
          : undefined,
      };

      expect(reconstructed.createdAt).toBeInstanceOf(Date);
      expect(reconstructed.updatedAt).toBeInstanceOf(Date);
      expect(reconstructed.deletedAt).toBeInstanceOf(Date);
    });

    it('should handle missing optional fields gracefully', () => {
      // Test partial data scenarios that might occur during migration
      const partialData = {
        id: 'partial-test',
        text: 'Partial todo',
        completedAt: undefined,
        createdAt: new Date(),
        updatedAt: new Date(),
        // deletedAt is intentionally omitted
      };

      const enhancedTodo: EnhancedTodo = {
        ...partialData,
        deletedAt: undefined,
      };

      expect(enhancedTodo.deletedAt).toBeUndefined();
      expect(enhancedTodo).toHaveProperty('id');
      expect(enhancedTodo).toHaveProperty('text');
      expect(enhancedTodo).toHaveProperty('completed');
    });
  });

  describe('filter logic validation', () => {
    it('should provide type safety for filter operations', () => {
      const todos: EnhancedTodo[] = [
        {
          id: '1',
          text: 'Active',
          completedAt: undefined,
          createdAt: new Date('2024-01-01T10:00:00Z'),
          updatedAt: new Date('2024-01-01T10:00:00Z'),
        },
        {
          id: '2',
          text: 'Completed',
          completed: true,
          createdAt: new Date('2024-01-01T10:00:00Z'),
          updatedAt: new Date('2024-01-01T11:00:00Z'),
        },
        {
          id: '3',
          text: 'Deleted',
          completedAt: undefined,
          createdAt: new Date('2024-01-01T10:00:00Z'),
          updatedAt: new Date('2024-01-01T11:00:00Z'),
          deletedAt: new Date('2024-01-01T12:00:00Z'),
        },
      ];

      // Filter functions with type safety
      const getVisibleTodos = (todos: EnhancedTodo[]): EnhancedTodo[] =>
        todos.filter((todo) => !todo.deletedAt);

      const getDeletedTodos = (todos: EnhancedTodo[]): EnhancedTodo[] =>
        todos.filter((todo) => !!todo.deletedAt);

      const getActiveTodos = (todos: EnhancedTodo[]): EnhancedTodo[] =>
        todos.filter((todo) => !todo.completed && !todo.deletedAt);

      const getCompletedTodos = (todos: EnhancedTodo[]): EnhancedTodo[] =>
        todos.filter((todo) => todo.completed && !todo.deletedAt);

      expect(getVisibleTodos(todos)).toHaveLength(2);
      expect(getDeletedTodos(todos)).toHaveLength(1);
      expect(getActiveTodos(todos)).toHaveLength(1);
      expect(getCompletedTodos(todos)).toHaveLength(1);
    });

    it('should validate filter type constraints', () => {
      const validFilters: EnhancedTodoFilter[] = [
        'all',
        'active',
        'completed',
        'deleted',
        'recently-updated',
        'recently-deleted',
        'recently-completed',
      ];

      validFilters.forEach((filter) => {
        const state: EnhancedTodoState = {
          todos: [],
          filter,
        };

        expect(state.filter).toBe(filter);
        expect(typeof state.filter).toBe('string');
      });
    });
  });
});
